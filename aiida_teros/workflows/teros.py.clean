"""
TEROS WorkChain for AiiDA-TEROS.

This module implements the main AiiDA-TEROS WorkChain for surface
thermodynamics calculations of oxide materials.
"""

import os
import numpy as np
from collections import Counter

from aiida.engine import WorkChain, ToContext, append_
from aiida.orm import (
    Code, StructureData, KpointsData, Float, Dict, List, Str, Bool
)
from aiida.plugins import WorkflowFactory
from aiida.engine import if_, while_, return_
from aiida.engine import calcfunction
from aiida.common.extendeddicts import AttributeDict

from aiida_teros.utils.structure import (
    generate_slabs, get_minimal_composition_factor, is_binary_oxide,
    get_element_counts, get_surface_area, create_o2_molecule
)
from aiida_teros.utils.vasp import get_vasp_builder
from aiida_teros.utils.io import (
    ensure_directory, save_latex_table, extract_file_from_folderdata,
    clean_extracted_files
)
from aiida_teros.utils.thermodynamics import (
    calculate_binary_oxide_limits, calculate_binary_surface_energy,
    calculate_ternary_surface_energy
)
from aiida_teros.plotting.binary import plot_binary_surface_energy
from aiida_teros.plotting.ternary import plot_ternary_surface_energy, plot_phase_diagram

# Define workflows
VaspWorkflow = WorkflowFactory('vasp.vasp')

class TerosWorkChain(WorkChain):
    """
    Master WorkChain for generating slab structures from a bulk structure
    and performing relaxation calculations on them.
    
    This WorkChain implements the TEROS (Thermodynamics of Oxide Surfaces) approach,
    which involves:
    1. Relaxing the bulk structure
    2. Generating symmetric slabs from the relaxed bulk
    3. Relaxing all generated slabs
    4. Calculating surface energies and identifying the most stable terminations
    5. Generating surface energy plots and phase diagrams
    """

    @classmethod
    def define(cls, spec):
        """
        Define the input and output specifications for the AiiDA workflow.
        This method sets up the input parameters, namespaces, and computational resources required for the workflow.
        It also outlines the steps of the workflow and defines the exit codes for error handling.
        
        Inputs:
            - code (Code): VASP calculation code.
            - bulk_structure (StructureData): Bulk material structure.
            - bulk_metal (StructureData): Bulk metal structure.
            - terminations (Namespace): Optional specific terminations to calculate.
            - incar_parameters_bulk (Namespace): INCAR parameters for relaxation of the bulk.
            - incar_parameters_bulk_metal (Namespace): INCAR parameters for relaxation of the bulk metal.
            - incar_parameters_slab (Namespace): INCAR parameters for relaxation of the slabs.
            - force_cutoff (Float): Force cutoff for relaxation.
            - steps (Int): Number of steps for relaxation.
            - kpoints_precision (Float): K-points mesh density precision.
            - potential_mapping (Dict): Mapping of potentials for each element.
            - potential_family (Str): Potential family for VASP calculations.
            - parser_settings (Dict): Settings for the parser.
            - computer_options (Dict): Computational resources and submission options.
            - miller_indices (List): Miller indices for slab generation.
            - min_slab_thickness (Float): Minimum slab thickness in Angstroms.
            - vacuum (Float): Vacuum spacing in Angstroms.
            - precision_phase_diagram (Int): Precision for the phase diagram.
            - total_energy_first_element (Float): Calculated total energy of the first element.
            - total_energy_o2 (Float): Calculated total energy of the O2 molecule.
            - HF_bulk (Float): Heat of formation of the bulk material.
            - path_to_graphs (Str): Path to store the graphs.
            
        Outputs:
            - bulk (Namespace): Exposed outputs from VaspWorkflow.
            - relaxations (Namespace): Dynamic namespace for relaxation outputs.
            - stable_structures (Namespace): Dynamic namespace for stable structures.
            
        Exit Codes:
            - 201: ERROR_GENERATE_SLABS_FAILED - Slab generation failed.
            - 202: ERROR_RELAX_SLABS_FAILED - Relaxation of slabs failed.
            - 203: ERROR_RELAX_BULK_FAILED - Relaxation of bulk structure failed.
            - 204: ERROR_RELAX_BULK_METAL_FAILED - Relaxation of bulk metal structure failed.
        """
        super().define(spec)

        # Define inputs
        spec.input(
            'code', 
            valid_type=Code, 
            help='VASP calculation code.'
        )
        spec.input(
            'bulk_structure', 
            valid_type=StructureData, 
            help='Bulk material structure.'
        )
        spec.input(
            'bulk_metal', 
            valid_type=StructureData, 
            help='Bulk material of the metal.'
        )
        spec.input_namespace(
            'terminations', 
            valid_type=StructureData, 
            required=False,
            help='Specific terminations to calculate.',
        )
        
        # INCAR parameters
        spec.input_namespace(
            'incar_parameters_bulk', 
            help='INCAR parameters for relaxation of the bulk.', 
            dynamic=True
        )
        spec.input_namespace(
            'incar_parameters_bulk_metal', 
            help='INCAR parameters for relaxation of the bulk metal.', 
            dynamic=True
        )
        spec.input_namespace(
            'incar_parameters_o2',
            help='INCAR parameters for relaxation of the O2 molecule.',
            dynamic=True
        )
        spec.input_namespace(
            'incar_parameters_slab', 
            help='INCAR parameters for relaxation of the slabs.', 
            dynamic=True
        )
        
        # Relaxation settings
        spec.input(
            'force_cutoff', 
            valid_type=Float, 
            default=lambda: Float(0.01),
            help='Force cutoff for relaxation.'
        )
        spec.input(
            'steps', 
            valid_type=Int, 
            default=lambda: Int(1000), 
            help='Number of steps for relaxation.'
        )
        spec.input(
            'kpoints_precision', 
            valid_type=Float, 
            default=lambda: Float(0.3), 
            help='K-points mesh density precision.'
        )
        
        # Potential settings
        spec.input(
            'potential_mapping', 
            valid_type=Dict, 
            help='Mapping of potentials for each element.'
        )
        spec.input(
            'potential_family', 
            valid_type=Str, 
            help='Potential family for VASP calculations.'
        )
        
        # Parser settings
        spec.input(
            'parser_settings', 
            valid_type=Dict, 
            help='Settings for the parser.'
        )
        
        # Computational resources
        spec.input(
            'computer_options', 
            valid_type=Dict, 
            help='Computational resources and submission options.'
        )
        
        # Slab generation settings
        spec.input(
            'miller_indices', 
            valid_type=List, 
            help='Miller indices for slab generation.'
        )
        spec.input(
            'min_slab_thickness', 
            valid_type=Float, 
            help='Minimum slab thickness in Angstroms.'
        )
        spec.input(
            'vacuum', 
            valid_type=Float, 
            default=lambda: Float(15), 
            help='Vacuum spacing in Angstroms.'
        )
        
        # Phase diagram settings
        spec.input(
            'precision_phase_diagram', 
            valid_type=Int, 
            default=lambda: Int(500), 
            help='Precision for the phase diagram.'
        )
        
        # Energy and formation enthalpy
        spec.input(
            'total_energy_first_element', 
            valid_type=Float, 
            help='Calculated total energy of the first element.'
        )
        spec.input(
            'total_energy_o2', 
            valid_type=Float, 
            help='Calculated total energy of the O2 molecule.'
        )
        spec.input(
            'HF_bulk', 
            valid_type=Float, 
            help='Heat of formation of the bulk material.'
        )
        
        # Path for storing graphs
        spec.input(
            'path_to_graphs', 
            valid_type=Str, 
            default=lambda: Str(os.getcwd()), 
            help='Path to store the graphs.'
        )

        # Define the workflow outline
        spec.outline(
            cls.run_relax_bulk,            # Step 1: Relax bulk structure
            cls.inspect_relax_bulk,        # Step 2: Inspect bulk relaxation results
            cls.run_relax_bulk_metal,      # Step 3: Relax bulk metal structure
            cls.inspect_relax_bulk_metal,  # Step 4: Inspect bulk metal relaxation
            cls.run_relax_o2,              # Step 5: Relax O2 molecule
            cls.inspect_relax_o2,          # Step 6: Inspect O2 relaxation
            cls.generate_slabs,            # Step 7: Generate slabs from relaxed bulk
            cls.run_relax_all_slabs,       # Step 8: Relax all generated slabs
            cls.inspect_relax_all_slabs,   # Step 9: Inspect relaxation results

            if_(cls.is_binary)(
                cls.analyze_binary_results,  # Step 10a: Analyze binary oxide results
                cls.plot_binary_results,     # Step 11a: Plot binary oxide results
            ).else_(
                cls.analyze_ternary_results,  # Step 10b: Analyze ternary oxide results
                cls.plot_ternary_results,     # Step 11b: Plot ternary oxide results
            )
        )

        # Define outputs
        spec.expose_outputs(
            VaspWorkflow, 
            namespace='bulk'
        )
        spec.expose_outputs(
            VaspWorkflow, 
            namespace='bulk_metal',
            required=False,
        )
        spec.expose_outputs(
            VaspWorkflow,
            namespace='o2',
            required=False,
        )
        spec.output_namespace(
            'relaxations', 
            dynamic=True
        )
        spec.output_namespace(
            'stable_structures', 
            dynamic=True
        )

        # Define exit codes for error handling
        spec.exit_code(
            201, 
            'ERROR_GENERATE_SLABS_FAILED', 
            message='Slab generation failed.'
        )
        spec.exit_code(
            202, 
            'ERROR_RELAX_SLABS_FAILED', 
            message='Relaxation of slabs failed.'
        )
        spec.exit_code(
            203, 
            'ERROR_RELAX_BULK_FAILED', 
            message='Relaxation of bulk structure failed.'
        )
        spec.exit_code(
            204, 
            'ERROR_RELAX_BULK_METAL_FAILED', 
            message='Relaxation of bulk metal structure failed.'
        )
        spec.exit_code(
            205, 
            'ERROR_RELAX_O2_FAILED', 
            message='Relaxation of O2 molecule failed.'
        )

    def is_binary(self):
        """
        Check if the bulk structure is binary or ternary.
        
        Returns:
            bool: True if binary, False if ternary.
        
        Raises:
            ValueError: If the structure is neither binary nor ternary.
        """
        return is_binary_oxide(self.inputs.bulk_structure)

    def run_relax_bulk(self):
        """
        Run a VASP relaxation of the bulk structure.
        """
        self.report('Running relaxation of the bulk structure.')

        try:
            # Get INCAR parameters for bulk relaxation
            incar_bulk = self.inputs.incar_parameters_bulk

            # Get the VASP builder with bulk INCAR parameters
            builder = get_vasp_builder(
                code=self.inputs.code,
                structure=self.inputs.bulk_structure,
                incar_parameters=incar_bulk,
                potential_family=self.inputs.potential_family.value,
                potential_mapping=self.inputs.potential_mapping.get_dict(),
                kpoint_density=self.inputs.kpoints_precision.value,
                parser_settings=self.inputs.parser_settings.get_dict(),
                computer_options=self.inputs.computer_options.get_dict(),
                label='relax_bulk_structure',
                description='Bulk relaxation of the material'
            )

            # Submit the bulk relaxation calculation
            future = self.submit(builder)
            self.report(f'Submitted VASP relaxation for bulk structure with PK {future.pk}')
            return ToContext(relax_bulk=future)

        except Exception as e:
            self.report(f'Failed to submit bulk relaxation: {e}')
            return self.exit_codes.ERROR_RELAX_BULK_FAILED

    def inspect_relax_bulk(self):
        """
        Inspect the result of the bulk relaxation.
        """
        if not self.ctx.relax_bulk.is_finished_ok:
            self.report(f'Relaxation of bulk failed with exit status {self.ctx.relax_bulk.exit_status}')
            return self.exit_codes.ERROR_RELAX_BULK_FAILED

        # Expose bulk relaxation outputs
        self.out_many(self.exposed_outputs(self.ctx.relax_bulk, VaspWorkflow, namespace='bulk'))
        self.report('Bulk relaxation completed successfully.')

    def generate_slabs(self):
        """
        Generate slab structures from the relaxed bulk structure using pymatgen's SlabGenerator.
        """
        try:
            if 'terminations' in self.inputs:  # Check if 'terminations' is provided as input
                self.ctx.slabs = list(self.inputs.terminations.values())
                self.report('Using user-provided terminations.')
            else:
                self.report('Generating slab structures from relaxed bulk structure.')
                # Retrieve the relaxed bulk structure
                relax_bulk_calc = self.ctx.relax_bulk
                if not relax_bulk_calc.is_finished_ok:
                    self.report('Bulk relaxation did not finish successfully.')
                    return self.exit_codes.ERROR_RELAX_BULK_FAILED

                relaxed_bulk = relax_bulk_calc.outputs.structure
                miller = tuple(self.inputs.miller_indices.get_list())
                min_slab_thickness = self.inputs.min_slab_thickness.value
                vacuum = self.inputs.vacuum.value

                # Generate slabs
                all_structures = generate_slabs(
                    relaxed_bulk, miller, min_slab_thickness, vacuum,
                    center_slab=True, lll_reduce=True
                )

                if not all_structures:
                    self.report('No slabs were generated.')
                    return self.exit_codes.ERROR_GENERATE_SLABS_FAILED

                self.ctx.slabs = all_structures
                self.report(f'Generated {len(all_structures)} slab structures.')

            # Assign slabs to dynamic output namespace
            structure_dict = {}
            for n, slab in enumerate(self.ctx.slabs, start=1):
                structure_dict[f'ST_{n}'] = slab
            self.out('relaxations.generated_terminations', structure_dict)

        except Exception as e:
            self.report(f'Failed to generate slabs: {e}')
            return self.exit_codes.ERROR_GENERATE_SLABS_FAILED

    def run_relax_all_slabs(self):
        """
        Run VASP relaxation calculations on all generated slabs.
        """
        self.report('Submitting relaxation calculations for all slabs.')

        self.ctx.relax_calculations = []

        for n, slab in enumerate(self.ctx.slabs, start=1):
            self.report(f'Running relaxation for slab structure_{n}.')

            try:
                # Get INCAR parameters for slab relaxation
                incar_slabs = self.inputs.incar_parameters_slab

                # Get the VASP builder with slab INCAR parameters
                builder = get_vasp_builder(
                    code=self.inputs.code,
                    structure=slab,
                    incar_parameters=incar_slabs,
                    potential_family=self.inputs.potential_family.value,
                    potential_mapping=self.inputs.potential_mapping.get_dict(),
                    kpoint_density=self.inputs.kpoints_precision.value,
                    parser_settings=self.inputs.parser_settings.get_dict(),
                    computer_options=self.inputs.computer_options.get_dict(),
                    label=f'relax_slab_{n}',
                    description=f'Relaxation of slab structure_{n}',
                    slab=True
                )

                # Submit the relaxation calculation
                future = self.submit(builder)
                self.report(f'Submitted relaxation for slab_{n} with PK {future.pk}')
                self.to_context(relax_calculations=append_(future))

            except Exception as e:
                self.report(f'Failed to submit relaxation for slab_{n}: {e}')
                return self.exit_codes.ERROR_RELAX_SLABS_FAILED

    def inspect_relax_all_slabs(self):
        """
        Inspect the results of all relaxation calculations.
        """
        self.report('Inspecting relaxation calculations for all slabs.')

        self.ctx.relaxed_structures = []
        self.ctx.relax_calcs = []

        for n, calc in enumerate(self.ctx.relax_calculations, start=1):
            calc = calc.called_descendants[-1]
            if not calc.is_finished_ok:
                self.report(f'Relaxation calculation for slab_{n} failed with exit status {calc.exit_status}')
                return self.exit_codes.ERROR_RELAX_SLABS_FAILED

            # Store the relaxed structure and calculation
            relaxed_structure = calc.outputs.structure
            self.ctx.relaxed_structures.append(relaxed_structure)
            self.ctx.relax_calcs.append(calc)
            
            # Aggregate outputs into a dictionary
            structure_dict = {}
            for output in calc.base.links.get_outgoing().all():
                structure_dict[output.link_label] = output.node
            # Assign the Dict node to the dynamic output namespace
            self.out(f'relaxations.ST_{n}', structure_dict)

            self.report(f'Relaxation for slab_{n} completed successfully.')

    def run_relax_bulk_metal(self):
        """
        Run a VASP relaxation of the bulk metal structure.
        """
        self.report('Running relaxation of the bulk metal structure.')

        try:
            # Get INCAR parameters for bulk metal relaxation
            incar_bulk_metal = self.inputs.incar_parameters_bulk_metal

            # Get the VASP builder with bulk metal INCAR parameters
            builder = get_vasp_builder(
                code=self.inputs.code,
                structure=self.inputs.bulk_metal,
                incar_parameters=incar_bulk_metal,
                potential_family=self.inputs.potential_family.value,
                potential_mapping=self.inputs.potential_mapping.get_dict(),
                kpoint_density=self.inputs.kpoints_precision.value,
                parser_settings=self.inputs.parser_settings.get_dict(),
                computer_options=self.inputs.computer_options.get_dict(),
                label='relax_bulk_metal_structure',
                description='Bulk relaxation of the metal'
            )

            # Submit the bulk metal relaxation calculation
            future = self.submit(builder)
            self.report(f'Submitted VASP relaxation for bulk metal structure with PK {future.pk}')
            return ToContext(relax_bulk_metal=future)

        except Exception as e:
            self.report(f'Failed to submit bulk metal relaxation: {e}')
            return self.exit_codes.ERROR_RELAX_BULK_METAL_FAILED

    def inspect_relax_bulk_metal(self):
        """
        Inspect the result of the bulk metal relaxation.
        """
        if not self.ctx.relax_bulk_metal.is_finished_ok:
            self.report(f'Relaxation of bulk metal failed with exit status {self.ctx.relax_bulk_metal.exit_status}')
            return self.exit_codes.ERROR_RELAX_BULK_METAL_FAILED

        # Expose bulk metal relaxation outputs
        self.out_many(self.exposed_outputs(self.ctx.relax_bulk_metal, VaspWorkflow, namespace='bulk_metal'))
        self.report('Metal bulk relaxation completed successfully.')
        
    def run_relax_o2(self):
        """
        Create an O2 molecule with ASE in a box and run a VASP relaxation.
        """
        self.report('Running relaxation of the O2 molecule.')

        try:
            # Create an O2 molecule
            o2_structure = create_o2_molecule()
            
            # Get INCAR parameters for O2 relaxation
            incar_o2 = self.inputs.incar_parameters_o2

            # Get the VASP builder with O2 INCAR parameters
            builder = get_vasp_builder(
                code=self.inputs.code,
                structure=o2_structure,
                incar_parameters=incar_o2,
                potential_family=self.inputs.potential_family.value,
                potential_mapping=self.inputs.potential_mapping.get_dict(),
                kpoint_density=self.inputs.kpoints_precision.value,
                parser_settings=self.inputs.parser_settings.get_dict(),
                computer_options=self.inputs.computer_options.get_dict(),
                label='relax_o2_molecule',
                description='Relaxation of the O2 molecule',
                slab=True  # Treat the molecule as a slab for k-point adjustment
            )

            # Submit the O2 relaxation calculation
            future = self.submit(builder)
            self.report(f'Submitted VASP relaxation for O2 molecule with PK {future.pk}')
            return ToContext(relax_o2=future)

        except Exception as e:
            self.report(f'Failed to submit O2 relaxation: {e}')
            return self.exit_codes.ERROR_RELAX_O2_FAILED

    def inspect_relax_o2(self):
        """
        Inspect the result of the O2 relaxation.
        """
        if not self.ctx.relax_o2.is_finished_ok:
            self.report(f'Relaxation of O2 failed with exit status {self.ctx.relax_o2.exit_status}')
            return self.exit_codes.ERROR_RELAX_O2_FAILED

        # Expose O2 relaxation outputs
        self.out_many(self.exposed_outputs(self.ctx.relax_o2, VaspWorkflow, namespace='o2'))
        self.report('O2 relaxation completed successfully.')

    def analyze_binary_results(self):
        """
        Calculate the surface total energy for all slab terminations in a binary oxide system.
        """
        self.report('Calculating the surface total energy for a binary system.')

        # Create output directory for thermodynamic results
        output_dir = ensure_directory(f'{self.inputs.path_to_graphs.value}/thermo_results/binary')

        # Get thermodynamic parameters
        delta_Hf = self.inputs.HF_bulk.value
        E_bulk = self.ctx.relax_bulk.outputs.misc.get_dict()['total_energies']['energy_extrapolated']
        bulk_structure = self.inputs.bulk_structure.get_ase()
        bulk_metal_structure = self.inputs.bulk_metal.get_ase()
        
        # Get the number of atoms in bulk_metal_structure as an integer
        num_atoms_bulk_metal_structure = len(bulk_metal_structure)
        E_bulk_metal = (self.ctx.relax_bulk_metal.outputs.misc.get_dict()['total_energies']['energy_extrapolated'] / 
                        num_atoms_bulk_metal_structure)
                        
        # Get the O2 energy (dividing by 2 to get per O atom)
        E_o2 = self.ctx.relax_o2.outputs.misc.get_dict()['total_energies']['energy_extrapolated'] / 2
        self.report(f'Calculated O2 energy per O atom: {E_o2:.4f} eV')

        # Determine the minimal composition of the bulk structure
        element_counts = Counter(atom.symbol for atom in bulk_structure)
        gcd_value = np.gcd.reduce(list(element_counts.values()))
        
        for element, natoms in element_counts.items():
            if element == 'O':
                y = natoms / gcd_value
            else:
                x = natoms / gcd_value
        self.report('Determined the minimal composition of the bulk structure.')

        # Calculate limits for the chemical potential of oxygen
        self.report('Calculating limits for the chemical potential of oxygen.')
        lower_limit = 1/y * (E_bulk - x * E_bulk_metal)
        upper_limit = lower_limit + 1/y * delta_Hf
        self.report(f'Chemical potential limits: [{lower_limit:.4f}, {upper_limit:.4f}] eV')

        mu_O_values = self.ctx.mu_O_values = [lower_limit, upper_limit]
        gammas = {}
        termination_data = []  # Data collection for LaTeX table
        
        for i, calc in enumerate(self.ctx.relax_calcs):
            self.report(f'Processing relaxation calculation {i+1}.')

            slab_structure = calc.outputs.structure
            slab_structure_ase = slab_structure.get_ase()
            E_slab = calc.outputs.misc.get_dict()['total_energies']['energy_extrapolated']

            # Get the non-oxygen element
            element_symbols = list(set(atom.symbol for atom in slab_structure_ase if atom.symbol != 'O'))
            if len(element_symbols) != 1:
                raise ValueError("Structure must contain exactly one non-oxygen element.")
            element = element_symbols[0]

            # Count atoms in the slab
            N_element_slab = len([atom for atom in slab_structure_ase if atom.symbol == element])
            N_O_slab = len([atom for atom in slab_structure_ase if atom.symbol == 'O'])

            if N_element_slab == 0 or N_O_slab == 0:
                raise ValueError("Number of non-oxygen or oxygen atoms cannot be zero.")

            # Calculate surface area
            lengths = slab_structure_ase.get_cell_lengths_and_angles()
            if lengths[0] <= 0 or lengths[1] <= 0:
                raise ValueError("Cell dimensions must be positive values.")

            A = lengths[0] * lengths[1]  # Area is the product of the x and y coordinates of the cell

            if A == 0:
                raise ValueError("Surface area cannot be zero.")

            E_bulk_per_fu = E_bulk / gcd_value  # Energy per formula unit

            # Calculate surface energy for lower and upper chemical potential limits
            gamma_values = []
            for mu_O in mu_O_values:
                # Calculate surface energy using the binary oxide formula
                gamma = (1 / (2 * A)) * (E_slab - (N_element_slab / x) * E_bulk_per_fu + 
                                        ((y / x) * N_element_slab - N_O_slab) * mu_O)
                gamma = gamma * 1.602176634e-19 * 1e20  # eV/Å² to J/m²
                gamma_values.append(gamma)

            self.report(f'Calculated surface Gibbs free energy for termination {i+1}.')

            gammas[f'Termination {i+1}'] = {
                'gamma_lower': gamma_values[0],
                'gamma_upper': gamma_values[1]
            }

            # Collect data for the LaTeX table
            termination_data.append([
                f'Termination {i+1}',
                E_slab,
                N_element_slab,
                N_O_slab,
                A
            ])

        self.ctx.gammas_binary = gammas
        self.report('Completed calculation of surface total energy for all terminations.')

        # Define headers for the LaTeX table
        headers = [
            "Termination",
            "$E_{slab}$ (eV)",
            "$N_{element}$",
            "$N_O$",
            "$A$ (\AA$^2$)"
        ]

        # Save the LaTeX table
        table_path = f'{output_dir}/termination_parameters_table.tex'
        save_latex_table(
            termination_data, 
            headers, 
            table_path, 
            title="Termination Parameters Table"
        )
        self.report(f'Generated LaTeX table with termination parameters and saved to {table_path}.')

    def plot_binary_results(self):
        """
        Plot surface energies as a function of oxygen chemical potential for a binary oxide.
        """
        output_dir = ensure_directory(f'{self.inputs.path_to_graphs.value}/thermo_results/binary')
        output_path = f'{output_dir}/surface_energy_plot.pdf'
        
        # Plot binary surface energies
        plot_binary_surface_energy(
            self.ctx.gammas_binary, 
            self.ctx.mu_O_values, 
            output_path
        )
        
        self.report(f'Generated surface energy plot and saved to {output_path}.')

    def analyze_ternary_results(self):
        """
        Calculate the surface total energy for all slab terminations in a ternary oxide system.
        """
        output_dir = ensure_directory(f'{self.inputs.path_to_graphs.value}/thermo_results/ternary')
        
        import pint
        ureg = pint.UnitRegistry()
        
        self.ctx.dict_results = {}
        termination_data = []  # Data collection for LaTeX table
        
        for n, calc in enumerate(self.ctx.relax_calcs, start=1):
            # Get energy parameters
            # Get energy of the first element (i.e., Ag) per atom from the bulk metal calculation
            bulk_metal_structure = self.inputs.bulk_metal.get_ase()
            num_atoms_bulk_metal = len(bulk_metal_structure)
            energy_ag = (self.ctx.relax_bulk_metal.outputs.misc.get_dict()['total_energies']['energy_extrapolated'] / 
                         num_atoms_bulk_metal) * ureg.eV
                         
            # Get energy of O2 per O atom from the O2 calculation
            energy_o2 = (self.ctx.relax_o2.outputs.misc.get_dict()['total_energies']['energy_extrapolated'] / 2) * ureg.eV
            
            kB = 1.38064852e-23 * ureg["J/K"]  # Boltzmann's constant
            mu_ex = 0.4 * ureg.eV
            delta_mu_ag = 0 * ureg.eV

            label = calc.label
            self.ctx.dict_results[label] = {}

            # Extract vasprun.xml from calc outputs
            vasprun_path = extract_file_from_folderdata(calc.outputs.retrieved, 'vasprun.xml')
            outcar_ase = read(vasprun_path, format='vasp-xml')
            os.remove(vasprun_path)

            # Extract vasprun.xml from bulk outputs
            vasprun_path = extract_file_from_folderdata(self.ctx.relax_bulk.outputs.retrieved, 'vasprun.xml')
            outcar_ase_bulk = read(vasprun_path, format='vasp-xml')
            divide_minimal_comp = get_minimal_composition_factor(StructureData(ase=outcar_ase_bulk))
            
            elements = outcar_ase_bulk.get_chemical_symbols()
            self.ctx.unique_symbols = unique_symbols = list(dict.fromkeys(elements))
            nAg_bulk = outcar_ase_bulk.get_chemical_symbols().count(unique_symbols[0]) / divide_minimal_comp
            nMe_bulk = outcar_ase_bulk.get_chemical_symbols().count(unique_symbols[1]) / divide_minimal_comp
            nO_bulk = outcar_ase_bulk.get_chemical_symbols().count(unique_symbols[2]) / divide_minimal_comp
            stoichiometry = [nAg_bulk, nMe_bulk, nO_bulk]
            energy_bulk = outcar_ase_bulk.get_potential_energy() * ureg["eV"] / divide_minimal_comp
            composition_bulk = [nAg_bulk, nMe_bulk, nO_bulk]
            os.remove(vasprun_path)

            self.ctx.dict_results[label]['energy_slab'] = outcar_ase.get_potential_energy() * ureg["eV"]
            self.ctx.dict_results[label]['a'] = outcar_ase.cell.cellpar()[0] * ureg["angstrom"]
            self.ctx.dict_results[label]['b'] = outcar_ase.cell.cellpar()[1] * ureg["angstrom"]
            self.ctx.dict_results[label]['elements'] = {}
            self.ctx.dict_results[label]['elements'][unique_symbols[0]] = outcar_ase.get_chemical_symbols().count(unique_symbols[0])
            self.ctx.dict_results[label]['elements'][unique_symbols[1]] = outcar_ase.get_chemical_symbols().count(unique_symbols[1])
            self.ctx.dict_results[label]['elements'][unique_symbols[2]] = outcar_ase.get_chemical_symbols().count(unique_symbols[2])

            # Calculate Delta values (excess atoms)
            self.ctx.dict_results[label]['Delta_Me_Ag'] = (
                self.ctx.dict_results[label]['elements'][unique_symbols[0]] - 
                composition_bulk[0] * self.ctx.dict_results[label]['elements'][unique_symbols[1]] / composition_bulk[1]
            )
            self.ctx.dict_results[label]['Delta_Me_O'] = (
                self.ctx.dict_results[label]['elements'][unique_symbols[2]] - 
                composition_bulk[2] * self.ctx.dict_results[label]['elements'][unique_symbols[1]] / composition_bulk[1]
            )
            
            # Calculate Psi term (energy term)
            self.ctx.dict_results[label]['psi'] = (
                self.ctx.dict_results[label]['energy_slab'] - 
                self.ctx.dict_results[label]['elements'][unique_symbols[1]] * energy_bulk / nMe_bulk - 
                energy_ag * self.ctx.dict_results[label]['Delta_Me_Ag'] - 
                0.5 * self.ctx.dict_results[label]['Delta_Me_O'] * energy_o2
            )

            # Calculate surface energy vs. delta_mu_o
            lim_delta_o = self.inputs.HF_bulk.value / stoichiometry[2]
            delta_mu = np.linspace(0, lim_delta_o, 20)
            delta_mu = [d * ureg.eV for d in delta_mu]
            gamma = []
            delta_mu_copy = delta_mu.copy()
            self.ctx.dict_results[label]['delta_mu'] = delta_mu_copy

            for m in delta_mu:
                g = (1 / (2 * self.ctx.dict_results[label]['a'] * self.ctx.dict_results[label]['b'])) * (
                    self.ctx.dict_results[label]['psi'] - 
                    self.ctx.dict_results[label]['Delta_Me_Ag'] * delta_mu_ag - 
                    self.ctx.dict_results[label]['Delta_Me_O'] * m
                )
                gamma.append(g.to('J/m^2').magnitude)
            self.ctx.dict_results[label]['gamma_delta_o'] = gamma

            # Collect data for the LaTeX table
            termination_data.append([
                label,
                self.ctx.dict_results[label]['Delta_Me_O'],
                self.ctx.dict_results[label]['Delta_Me_Ag'],
                self.ctx.dict_results[label]['psi']
            ])

            # Calculate phase diagram data
            precision = self.inputs.precision_phase_diagram.value
            self.ctx.lim_delta_ag = lim_delta_ag = self.inputs.HF_bulk.value / stoichiometry[0]
            self.ctx.lim_delta_o = lim_delta_o = self.inputs.HF_bulk.value / stoichiometry[2]
            delta_ag = np.linspace(0, lim_delta_ag, precision)
            delta_o = np.linspace(0, lim_delta_o, precision)
            gamma_delta_ag_delta_o = np.zeros((precision, precision))
            
            for i, ag in enumerate(delta_ag):
                for j, o in enumerate(delta_o):
                    gamma_delta_ag_delta_o[i, j] = (
                        1 / (2 * self.ctx.dict_results[label]['a'].magnitude * self.ctx.dict_results[label]['b'].magnitude)
                    ) * (
                        self.ctx.dict_results[label]['psi'].magnitude - 
                        self.ctx.dict_results[label]['Delta_Me_Ag'] * ag - 
                        self.ctx.dict_results[label]['Delta_Me_O'] * o
                    )

            self.ctx.dict_results[label]['delta_ag'] = delta_ag
            self.ctx.dict_results[label]['delta_o'] = delta_o
            self.ctx.dict_results[label]['gamma_delta_ag_delta_o'] = gamma_delta_ag_delta_o

            # Convert pint.Quantity objects to their magnitude values
            for key, value in self.ctx.dict_results[label].items():
                if isinstance(value, ureg.Quantity):
                    self.ctx.dict_results[label][key] = value.magnitude

        # Sort the results dictionary by label
        self.ctx.dict_results = dict(sorted(self.ctx.dict_results.items(), key=lambda item: item[0]))

        # Define headers for the LaTeX table
        headers = [
            "Termination Label",
            "$N_O - xN_B$",
            "$N_A - yN_B$",
            "$\Theta$ (eV)"
        ]

        # Save the LaTeX table
        table_path = f'{output_dir}/ternary_parameters_table.tex'
        save_latex_table(
            termination_data, 
            headers, 
            table_path, 
            title="Termination Parameters Table"
        )
        self.report(f'Generated LaTeX table with ternary termination parameters and saved to {table_path}.')

        # Find the most stable structures at different chemical potentials
        delta_mu = np.array([dm.to('eV').magnitude for dm in self.ctx.dict_results[list(self.ctx.dict_results.keys())[0]]['delta_mu']])
        target_delta_mu = [0.0, -2.0]
        target_labels = ['delta_mu = 0 eV', 'delta_mu = -2 eV']
        most_stable = {}

        for target, label in zip(target_delta_mu, target_labels):
            # Find the index of the closest delta_mu value
            idx = np.argmin(np.abs(delta_mu - target))
            closest_delta_mu = delta_mu[idx]
            print(f"Closest delta_mu to {target} eV is {closest_delta_mu} eV at index {idx}")

            # Extract gamma_delta_o for all structures at this index
            gamma_at_target = {}
            for structure_name, info_structure in self.ctx.dict_results.items():
                gamma_value = info_structure['gamma_delta_o'][idx]
                gamma_at_target[structure_name] = gamma_value

            # Find the structure with the minimum gamma_delta_o
            most_stable_structure = min(gamma_at_target, key=gamma_at_target.get)
            most_stable[target] = most_stable_structure

            # Report the most stable structure
            self.report(f'Most stable structure at {label}: {most_stable_structure}')

        # Store the most stable structures in the context
        self.ctx.most_stable_delta_mu_0 = most_stable.get(0.0, None)
        self.ctx.most_stable_delta_mu_minus_2 = most_stable.get(-2.0, None)

        # Output the stable structures
        stable_structures = []
        for calc in self.ctx.relax_calcs:
            if calc.label == self.ctx.most_stable_delta_mu_0 or calc.label == self.ctx.most_stable_delta_mu_minus_2:
                stable_structures.append(calc)

        for calc in stable_structures:
            structure_dict = {}
            for output in calc.base.links.get_outgoing().all():
                structure_dict[output.link_label] = output.node
            # Assign the Dict node to the dynamic output namespace
            self.out(f'stable_structures.{calc.label}', structure_dict)

    def plot_ternary_results(self):
        """
        Plot surface energies and phase diagram for a ternary oxide.
        """
        output_dir = ensure_directory(f'{self.inputs.path_to_graphs.value}/thermo_results/ternary')
        
        # Plot surface free energies
        energy_plot_path = f'{output_dir}/surface_free_energies.pdf'
        plot_ternary_surface_energy(
            self.ctx.dict_results, 
            energy_plot_path
        )
        
        # Plot phase diagram
        phase_diagram_path = f'{output_dir}/surface_phase_diagram.pdf'
        plot_phase_diagram(
            self.ctx.dict_results,
            self.ctx.unique_symbols,
            self.ctx.lim_delta_ag,
            self.ctx.lim_delta_o,
            phase_diagram_path
        )
        
        self.report(f'Generated surface energy plot and saved to {energy_plot_path}.')
        self.report(f'Generated phase diagram and saved to {phase_diagram_path}.')